#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Oct  8 15:13:44 2025

@author: fecmacbook
"""

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HK Restaurant Cuisines | 2018–2023</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <!-- MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css">
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <!-- Heatmap plugin -->
  <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>

  <!-- PapaParse for CSV -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- d3 for summarising -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    #app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    #toolbar {
      display: grid;
      grid-template-columns: 1fr auto auto auto auto;
      gap: 12px;
      align-items: center;
      padding: 10px 12px;
      border-bottom: 1px solid #e5e7eb;
      background: #fafafa;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Arial, sans-serif;
      position: relative;
      z-index: 500;
    }
    #map { width: 100%; height: 100%; }
    .pill {
      padding: 6px 10px; border: 1px solid #e5e7eb; border-radius: 999px; background: #fff;
    }
    .btn {
      padding: 6px 10px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff; cursor: pointer;
    }
    .btn:active { transform: translateY(1px); }
    .panel {
      position: absolute; right: 10px; z-index: 1000;
      background: rgba(255,255,255,0.97); border-radius: 12px; padding: 10px 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.08); max-width: 320px; font-size: 13px; line-height: 1.3;
      top: 80px; /* fallback below toolbar */
      max-height: calc(100vh - 120px);
      overflow: auto;
    }
    .panel h4 { margin: 6px 0 8px 0; font-size: 14px; }
    .flex { display: flex; align-items: center; gap: 8px; }
    .muted { color: #6b7280; }
    #cuisineBox { max-height: 220px; overflow: auto; padding: 6px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff; }
    label.chk { display: grid; grid-template-columns: 18px 1fr auto; gap: 6px; align-items: center; margin: 2px 0; }
    .footer-note { font-size: 12px; color: #6b7280; padding: 6px 12px; }
    .badge { display:inline-block; padding:2px 6px; border-radius:999px; background:#eef2ff; color:#3730a3; font-size:12px; }
    .warn { background:#fff7ed; color:#9a3412; }
    @media (max-width: 900px) {
      .panel {
        left: 50%;
        right: auto;
        transform: translateX(-50%);
        width: min(92vw, 360px);
        max-height: 45vh;
      }
    }
  </style>
</head>
<body>
<div id="app">
  <div id="toolbar">
    <div class="flex" style="gap:14px;">
      <div class="pill">
        <span class="muted">Year:</span>
        <input id="yearRange" type="range" min="2018" max="2023" step="1" value="2018" style="vertical-align: middle;">
        <strong id="yearLabel">2018</strong>
        <button id="playBtn" class="btn" title="Auto-play">▶︎</button>
        <button id="fitBtn" class="btn" title="Fit to current data">Fit</button>
      </div>

      <div class="pill">
        <span class="muted">Mode:</span>
        <label class="flex"><input id="modeCluster" type="radio" name="mode" checked> Markers (Cluster)</label>
        <label class="flex"><input id="modeHeat" type="radio" name="mode"> Heatmap</label>
      </div>

      <div class="pill">
        <span class="muted">Basemap:</span>
        <select id="basemapSelect">
          <option value="osm">OpenStreetMap Standard</option>
          <option value="positron">Carto Positron (light)</option>
          <option value="voyager">Carto Voyager (color)</option>
        </select>
      </div>
    </div>

    <div class="pill">
      <span class="muted">Cuisine filter:</span>
      <input id="cuisineSearch" placeholder="Search cuisines…" style="border:0; outline: none;">
    </div>

    <div class="pill">
      <button id="resetBtn" class="btn">Reset (All)</button>
      <button id="clearBtn" class="btn">Clear (None)</button>
      <!-- 新增：Heatmap 面积计算按钮 -->
      <button id="measureBtn" class="btn" title="Estimate heatmap area at current zoom">Measure heat area</button>
    </div>
  </div>

  <div id="map"></div>
</div>

<div class="panel" id="panel">
  <h4>Overview</h4>
  <div id="stats"></div>
  <div id="loadInfo" class="muted" style="margin:6px 0;"></div>
  <div id="buildInfo" class="muted" style="margin:6px 0;"></div>
  <h4 style="margin-top:8px;">Cuisines</h4>
  <div id="cuisineBox"></div>
   <div class="footer-note">
      Map data © OpenStreetMap contributors; tiles by OSM / Carto.<br/>
      Data collected and website created by Zheng Gang, with guidance from Prof. Peter K. Koh and the Koh Research Group (Department of Geography, The University of Hong Kong).
      <span class="muted">— build 20251008-01</span>
   </div>

</div>

<script>
  // Place panel dynamically under toolbar (prevents overlap)
  function positionPanel() {
    const tb = document.getElementById('toolbar');
    const panel = document.getElementById('panel');
    if (!tb || !panel) return;
    const top = tb.offsetHeight + 10; // 10px gap
    panel.style.top = top + 'px';
    panel.style.maxHeight = 'calc(100vh - ' + (top + 20) + 'px)'; // keep some bottom margin
  }
  window.addEventListener('load', positionPanel);
  window.addEventListener('resize', positionPanel);

  // File mapping
  const YEAR_FILES = {
    2018: "data/201801_processed.csv",
    2019: "data/201901_processed.csv",
    2020: "data/202001_processed.csv",
    2021: "data/202101_processed.csv",
    2022: "data/202202_processed.csv", /* 如果你的真实文件是 202201_processed.csv，请改回去 */
    2023: "data/202301_processed.csv",
  };

  // Global state
  const dataByYear = {};   // year -> array of rows
  let allCuisines = new Set();
  // Tri-state selection:
  //   null  => ALL cuisines selected
  //   Set() size==0 => NONE selected
  //   Set() size>0  => SUBSET selected
  let selectedCuisines = null;
  let currentYear = 2018;
  let playing = false;
  let playTimer = null;

  // Leaflet map
  const map = L.map('map', { preferCanvas: true }).setView([22.3193, 114.1694], 11);

  const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
  });

  const positron = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
  });

  const voyager = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/rastertiles/voyager/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
  });

  const basemaps = { osm, positron, voyager };
  osm.addTo(map);

  // MarkerCluster layer (tuned for big sets)
  const clusterLayer = L.markerClusterGroup({
    disableClusteringAtZoom: 17,
    maxClusterRadius: 60,
    spiderfyOnMaxZoom: true,
    chunkedLoading: true,
    chunkDelay: 50,
    chunkInterval: 200,
    removeOutsideVisibleBounds: true,
    animateAddingMarkers: false,
    chunkProgress: function (processed, total, elapsed) {
      const el = document.getElementById('buildInfo');
      if (!el) return;
      if (processed === total) el.textContent = '';
      else el.textContent = `Clustering… ${processed.toLocaleString()} / ${total.toLocaleString()}`;
    },
  }).addTo(map);

  let heatLayer = null;

  // Helpers
  function loadCSV(url) {
    return new Promise((resolve, reject) => {
      Papa.parse(url, {
        header: true,
        download: true,
        dynamicTyping: true,
        skipEmptyLines: true,
        complete: (res) => {
          const cleaned = res.data.map(row => ({
            Main_Cuisine: (row.Main_Cuisine ?? row.main_cuisine ?? row.Cuisine ?? '').toString().trim(),
            Latitude: parseFloat(row.Latitude ?? row.latitude ?? row.lat),
            Longitude: parseFloat(row.Longitude ?? row.longitude ?? row.lon ?? row.lng),
            Name: row.Name ?? row.Restaurant_Name ?? row.name ?? '',
          })).filter(r => Number.isFinite(r.Latitude) && Number.isFinite(r.Longitude) && r.Main_Cuisine);
          resolve(cleaned);
        },
        error: (err) => reject(err)
      });
    });
  }

  async function initData() {
    const years = Object.keys(YEAR_FILES).map(y => +y).sort((a,b) => a-b);
    let info = [];
    for (const y of years) {
      try {
        const rows = await loadCSV(YEAR_FILES[y]);
        dataByYear[y] = rows;
        rows.forEach(r => allCuisines.add(r.Main_Cuisine));
        info.push(`<span class="badge">${y}: ${rows.length.toLocaleString()} restaurants</span>`);
      } catch (e) {
        console.warn('Failed to load', y, e);
        dataByYear[y] = [];
        info.push(`<span class="badge warn">${y}: 0 (failed)</span>`);
      }
    }
    document.getElementById('loadInfo').innerHTML = info.join(' ');
    // Sort cuisines
    allCuisines = new Set(Array.from(allCuisines).sort((a,b) => a.localeCompare(b)));
    renderCuisineList();

    // Auto-switch to the first year that has data
    const firstWithData = years.find(y => (dataByYear[y]||[]).length > 0);
    if (firstWithData) {
      currentYear = firstWithData;
      document.getElementById('yearRange').value = firstWithData;
      document.getElementById('yearLabel').textContent = firstWithData;
    }
  }

  function isAllSelected() { return selectedCuisines === null; }
  function isNoneSelected() { return (selectedCuisines instanceof Set) && selectedCuisines.size === 0; }

  function renderCuisineList(filterText='') {
    const box = document.getElementById('cuisineBox');
    box.innerHTML = '';
    const frag = document.createDocumentFragment();
    const allArr = Array.from(allCuisines);

    for (const c of allArr) {
      if (filterText && !c.toLowerCase().includes(filterText.toLowerCase())) continue;
      const id = 'c_' + c.replace(/\W+/g, '_');
      const label = document.createElement('label');
      label.className = 'chk';

      const chk = document.createElement('input');
      chk.type = 'checkbox';
      chk.id = id;

      if (isAllSelected()) chk.checked = true;
      else if (isNoneSelected()) chk.checked = false;
      else chk.checked = selectedCuisines.has(c);

      chk.addEventListener('change', () => {
        if (isAllSelected()) selectedCuisines = new Set(allCuisines);
        if (chk.checked) selectedCuisines.add(c); else selectedCuisines.delete(c);
        if (selectedCuisines.size === allCuisines.size) selectedCuisines = null;
        updateMap();
        refreshCuisineCounts();
      });

      const nameSpan = document.createElement('span');
      nameSpan.textContent = c;

      const count = document.createElement('span');
      count.className = 'muted';
      count.dataset.cuisine = c;

      label.appendChild(chk);
      label.appendChild(nameSpan);
      label.appendChild(count);
      frag.appendChild(label);
    }
    box.appendChild(frag);
    refreshCuisineCounts();
  }

  function getFilteredRows() {
    const rows = dataByYear[currentYear] || [];
    if (isAllSelected()) return rows;
    if (isNoneSelected()) return [];
    return rows.filter(r => selectedCuisines.has(r.Main_Cuisine));
  }

  function refreshCuisineCounts() {
    const rows = getFilteredRows();
    const stats = d3.rollup(rows, v => v.length, d => d.Main_Cuisine);
    const total = rows.length;
    document.getElementById('stats').innerHTML = `
      <div><b>Year:</b> <b>${currentYear}</b></div>
      <div><b>Restaurants:</b> ${total.toLocaleString()}</div>
      <div><span class="muted">Filter:</span> ${ isAllSelected() ? 'All' : (isNoneSelected() ? 'None' : 'Subset') }</div>
    `;
    document.querySelectorAll('#cuisineBox span.muted').forEach(el => {
      const c = el.dataset.cuisine;
      const n = stats.get(c) ?? 0;
      el.textContent = n.toLocaleString();
    });
  }

  // ---- Marker builder (robust & cancellable) ----
  let __markerBuildToken = { id: 0 };

  function cancelMarkerBuild() {
    __markerBuildToken.id++;
    const el = document.getElementById('buildInfo');
    if (el) el.textContent = '';
  }

  function startMarkerBuild(rows) {
    const myId = ++__markerBuildToken.id;
    const el = document.getElementById('buildInfo');
    const BATCH = 800;
    let i = 0, total = rows.length;

    function step() {
      if (myId !== __markerBuildToken.id) { if (el) el.textContent = ''; return; }
      const next = Math.min(i + BATCH, total);
      const batch = [];
      for (let k = i; k < next; k++) {
        const r = rows[k];
        if (!Number.isFinite(r.Latitude) || !Number.isFinite(r.Longitude)) continue;
        const nm = (r.Name ? String(r.Name) : 'Unnamed').replace(/[`\\]/g, "'");
        const cu = String(r.Main_Cuisine || '').replace(/[`\\]/g, "'");
        const m = L.marker([r.Latitude, r.Longitude], { title: nm || cu }).bindPopup(
          '<div style="min-width:180px">' +
          '<div><b>' + nm + '</b></div>' +
          '<div>Cuisine: ' + cu + '</div>' +
          '<div>Coords: ' + r.Latitude.toFixed(5) + ', ' + r.Longitude.toFixed(5) + '</div>' +
          '<div>Year: ' + currentYear + '</div>' +
          '</div>'
        );
        batch.push(m);
      }
      if (batch.length) clusterLayer.addLayers(batch);
      i = next;
      if (el) el.textContent = (i < total)
        ? ('Adding markers… ' + i.toLocaleString() + ' / ' + total.toLocaleString())
        : '';

      if (i < total) setTimeout(step, 0);
    }
    setTimeout(step, 0);
  }

function updateMap() {
    const rows = getFilteredRows();
    refreshCuisineCounts();

    // Cancel any previous marker build
    cancelMarkerBuild();

    // Clear layers
    clusterLayer.clearLayers();
    if (heatLayer) { map.removeLayer(heatLayer); heatLayer = null; }

    const modeHeat = document.getElementById('modeHeat').checked;

    if (modeHeat) {
      const heatPts = rows.map(r => [r.Latitude, r.Longitude, 0.6]);
      if (heatPts.length) {
        heatLayer = L.heatLayer(heatPts, { radius: 18, blur: 16, maxZoom: 17, minOpacity: 0.35 }).addTo(map);
      }
      return;
    }

    if (!rows.length) {
      const el = document.getElementById('buildInfo'); if (el) el.textContent = '';
      return;
    }

    // Build markers progressively
    startMarkerBuild(rows);
}

  function fitToData() {
    const rows = getFilteredRows();
    if (!rows.length) return;
    const latlngs = rows.map(r => [r.Latitude, r.Longitude]);
    const b = L.latLngBounds(latlngs);
    map.fitBounds(b.pad(0.05));
  }

  /* 新增：在当前缩放下估算 Heatmap 面积（阈值法）
     thresholdAlpha ∈ [0..255]；例如 64 ≈ 25% 透明度。
     注意：这是可视化近似（像素核），结果会随缩放变化。 */
  function measureHeatArea(thresholdAlpha = 64) {
    if (!heatLayer) {
      alert('Please switch to Heatmap mode first.');
      return;
    }
    // 兼容不同 leaflet.heat 版本
    let canvas = heatLayer._canvas;
    if (!canvas && heatLayer._heatmap && heatLayer._heatmap._canvas) {
      canvas = heatLayer._heatmap._canvas;
    }
    if (!canvas) {
      alert('Heatmap canvas is not ready yet. Try again in a moment.');
      return;
    }
    const ctx = canvas.getContext('2d');
    const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = img.data;

    let hotPixels = 0;
    for (let i = 3; i < data.length; i += 4) { // 只看 alpha 通道
      if (data[i] >= thresholdAlpha) hotPixels++;
    }

    // 用地图中心的分辨率近似换算（香港区域内误差较小）
    const c = map.getCenter();
    const z = map.getZoom();
    const metersPerPixel = 156543.03392 * Math.cos(c.lat * Math.PI/180) / Math.pow(2, z);
    const area_m2 = hotPixels * metersPerPixel * metersPerPixel;
    const area_km2 = area_m2 / 1e6;

    alert(`Heat area (alpha ≥ ${thresholdAlpha}/255) ≈ ${area_km2.toFixed(2)} km² at zoom ${z}`);
  }

  // Wire events
  document.getElementById('yearRange').addEventListener('input', (e) => {
    currentYear = +e.target.value;
    document.getElementById('yearLabel').textContent = currentYear;
    updateMap();
    fitToData();
  });

  document.getElementById('modeCluster').addEventListener('change', () => { updateMap(); fitToData(); });
  document.getElementById('modeHeat').addEventListener('change', () => { updateMap(); fitToData(); });

  document.getElementById('basemapSelect').addEventListener('change', (e) => {
    const val = e.target.value;
    Object.values(basemaps).forEach(l => map.removeLayer(l));
    basemaps[val].addTo(map);
  });

  document.getElementById('resetBtn').addEventListener('click', () => {
    selectedCuisines = null; // All
    document.getElementById('cuisineSearch').value = '';
    renderCuisineList('');
    updateMap();
    fitToData();
  });

  document.getElementById('clearBtn').addEventListener('click', () => {
    selectedCuisines = new Set(); // None
    document.getElementById('cuisineSearch').value = '';
    renderCuisineList('');
    updateMap();
  });

  // 新增：面积计算按钮
  document.getElementById('measureBtn').addEventListener('click', () => measureHeatArea(64));

  document.getElementById('cuisineSearch').addEventListener('input', (e) => renderCuisineList(e.target.value));
  document.getElementById('fitBtn').addEventListener('click', fitToData);

  document.getElementById('playBtn').addEventListener('click', () => {
    playing = !playing;
    const btn = document.getElementById('playBtn');
    btn.textContent = playing ? '⏸︎' : '▶︎';
    if (playing) {
      playTimer = setInterval(() => {
        const yr = +document.getElementById('yearRange').value;
        const next = yr >= 2023 ? 2018 : yr + 1;
        document.getElementById('yearRange').value = next;
        currentYear = next;
        document.getElementById('yearLabel').textContent = currentYear;
        updateMap();
        // 注意：自动播放时 Heatmap 下不自动 fit（保持你之前的行为）
        if (!document.getElementById('modeHeat').checked) { fitToData(); }
      }, 1200);
    } else {
      clearInterval(playTimer);
    }
  });

  (async function main() {
    document.getElementById('yearLabel').textContent = currentYear;
    await initData();
    updateMap();
    fitToData();
    positionPanel();
  })();
</script>
</body>
</html>
